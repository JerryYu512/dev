# 组件开发建议

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [组件开发建议](#组件开发建议)
  - [1. 定义](#1-定义)
  - [2. 为什么要做组件开发](#2-为什么要做组件开发)
  - [3. 组件规范](#3-组件规范)
    - [3.1 公司规范](#31-公司规范)
    - [3.2 组件通用规范](#32-组件通用规范)
      - [3.2.1 文件结构](#321-文件结构)
      - [3.2.2 编码相关](#322-编码相关)
      - [3.2.3 迭代与维护](#323-迭代与维护)
      - [3.2.4 依赖库](#324-依赖库)
      - [3.2.5 构建发布](#325-构建发布)
      - [3.2.6 文档](#326-文档)
      - [3.2.7 测试](#327-测试)
      - [3.2.8 组件设计原则](#328-组件设计原则)
  - [4. 文档修订记录](#4-文档修订记录)

<!-- /code_chunk_output -->

----

>*作者：wotsen<<astralrovers@outlook.com>>*
>*文件名：组件开发建议 -coding:UTF-8*
>*日期：2021-6-26*
>*概要：对于组件开发的一些建议*
>*声明：*

----

## 1. 定义

- **组件是能够完成某种功能并且向外提供若干个使用这个功能的接口的可重用的代码集。**
- **基于功能划分的单位，其内部可能包含更小粒度的模块、组件。**
- **相对于模块而言，组件更偏向于发行、发布；模块偏向于逻辑、设计上的划分。两者没有包含关系，模块可能由多个组件实现，组件内部又可能包含多个模块。**

----

## 2. 为什么要做组件开发

良好的应用程序在功能上的实现通常由组件、模块构成，无论分层架构、事件驱动架构、插件架构、微服务架构的软件都离不开组件的实现。

一些应用程序存在的问题是功能本身相对独立，但是在实现时遍布整个工程，导致以下问题：

- 出现问题时定位排查困难；
- 修改涉及范围大，且容易出错和遗漏，测试时需要花费更多精力；
- 应用程序迭代、重构困难、甚至无法维护；

组件开发的优势：

- 程序功能结构清晰：
  - 组件基于功能单位，具有层次结构，最小粒度的组件个数代表多少功能；
- 分工明确，有利于团队开发大型项目；
  - 企业应用程序通常包含许多复杂的功能与模块。系统架构设计完成后，实现上被划分为大大小小的组件，如：结构、硬件、软件，每个层级都有对应粒度大熊啊，最终由部门->组->个人进行开发；
- 利于代码复用；
  - 组件开发最大的原因就在于可重用，通过可以复用的代码来降低开发成本，提高开发效率；
- 利于维护；
  - 组件本身偏向于发布，因此组件通常拥有自身的版本管理，使用者能够通过组件的版本修订记录得知组件做了哪些修改，从而决定要不要更新、应用程序是否需要做对应的修改；
  - 应用程序本身的版本迭代不对组件造成影响；
  - 缺陷排查更容易，一般而言迭代维护时间越长的组件越稳定；
  - 为应用程序框架重构时提供便利。

常见的良好组件：标准库、知名开源库。

----

## 3. 组件规范

组件存在许多优点，同样需要一系列的规范来保证组件能够发挥出其原本的作用，否则只会适得其反。

组件设计规范通常由基本分进行约束：

- 公司，组织，团体。内部公开、外部公开的由公司定义的开发规范，如[Google开源项目风格指南](https://github.com/zh-google-styleguide/zh-google-styleguide)；
- 软件行业通用、约定俗成的开发规范，如github项目开发流程。

### 3.1 公司规范

- **编码规范**，[Google开源项目风格指南](https://github.com/zh-google-styleguide/zh-google-styleguide)；
- **文档规范**，需求、设计、测试用例、测试报告、开发手册、使用手册。

----

### 3.2 组件通用规范

组件通用规范更多是行业约定俗成，符合更广泛的开发使用习惯，可参考知名的开源项目。

----

#### 3.2.1 文件结构

文件结构非常重要，能够让人一眼明白组件项目由哪几部分组成，对应的文件需要在哪里寻找。

组件项目的顶层文件结构通常由一下组成：

```shell
├── README.md         # 项目概述，简单的指导文档
├── build             # 用于存放构建时的中间生成物，临时生成
├── dist              # 用于存放组件发布包，临时生成，以下文件夹是发布包需要包含的内容
│   ├── README.md     # 指导文档
│   ├── changlog      # 更新日志
│   ├── samples       # 示例代码
│   ├── docs          # 用户文档
│   ├── include       # 头文件
│   │   └── component
│   ├── lib           # 库文件
│   ├── bin           # 可执行文件
│   └── name-platform-version-mode.tar.gz # 发布包，以上文件的压缩，如：ars-x64-1.0.0-release.tar.gz
├── docs              # 文档路径
│   ├── dev-doc       # 开发文档
│   └── user-doc      # 用户文档
├── install           # 默认组件安装路ing，没指定安装路径时放在此处
│   └── name-platname-version-mode.tar.gz # 发布包，include,lib,bin未写出来
├── target            # 用于存放对应平台的目标生成物(可以按平台或者版本分目录)，这里存放的是发布版本。可以用于版本控制系统记录
│   └── platform
├── include           # 构建好的依赖库头文件
│   └── cjson
├── lib               # 构建好的依赖库文件
├── bin               # 构建好的依赖库可执行文件
├── mk                # Makefile依赖
│   ├── config.mk     # 配置
│   ├── src.mk        # 组件源码编译列表
│   └── ut.mk         # 单元测试编译列表
├── Makefile          # make构建唯一入口
├── samples           # 示例代码
├── src               # 组件源码
└── unittest          # 单元测试代码
├── thirdparty        # 依赖库源码
├── tool              # 辅助工具
```

更完善的应该还有：持续集成，代码风格，ide配置等等。

----

#### 3.2.2 编码相关

- 接口规范：
  - 格式统一，同一个组件的结构保持相同的前缀(包括数据结构定义)，或者使用命名空间，避免接口冲突；
  - 返回值的错误码需要使用枚举；
  - 常用`const`对返回值、参数加以约束；
  - 输入参数在前，输出参数在后；
  - 全局接口需要对参数有效性进行校验，私有接口使用断言；
- 变量，接口声明：
  - 尽量少使用全局变量及函数，多使用`static`修饰符，利于模块封装性和避免全局接口命名冲突；
  - 全局变量改为`static`变量，添加一组对该变量进行修改、查询的全局接口(注意线程安全)，对于变量的可操作性更强；
- 错误码：
  - 以枚举类型标识，并以16进制数字定义；
  - 高2字节表明错误类别(模块)，低2字节表明具体错误，全0标识正确，全1标识未知；
  - 提供错误码翻译接口，输入错误码返回人类能理解的错误说明字符串；
  - 另一种方式可以以负值表示错误，不同负值代表不同的错误；以0、正值标识接口执行结果，但是仍然需要如前面所述，每个错误码都需要使用枚举来区分：错误的类别，具体错误，以便`debug`时排查问题；
- 开放头文件约束：
  - 不提供组件使用者使用不到的接口、数据类型，减少兼容性风险，增加封装性，减少使用者的理解难度；
  - 不包含使用者使用不到的头文件；
  - `c`组件的头文件需要兼容考虑到`c++`使用场景；
  - `c++`头文件增加命名空间；
  - 少用宏定义，多使用枚举于接口，宏定义对代码的污染性更大且容易出错；
- 一般组件的基本开放接口：
  - 版本号(组件版本号，编译日期)；
  - 错误码翻译接口；
  - 日志等级接口：
    - 等级：INFO，WARNING，ERROR，FATAL，NONE；
    - 格式：`|时间|等级|(线程id)|模块名称|文件|函数|行|错误信息|`；
    - 提供日志重定向接口；
- 组件配置接口(可选)：`config/setup/release`；
- 组件启动/停止(可选，存在时配对)：`start/stop`；
- 资源申请/释放(可选，存在时需要配置)：`alloc/free`；
- 组件状态查询(可选)：`status`；
- 文件应用约束：
  - 不要包含不使用的头文件；
  - 头文件包含避免环状；
  - 头文件需要自洽，即该头文件被使用时不需要再包含其他头文件才能使用；
- 不要直接引用应用程序内的文件、数据结构、接口(使用方式应该是单向)，使用类型转换、回调的方式；
- 注意结构体对齐，数据存储和协议传输使用8字节对齐，注意包含指针的问题(指针大小和系统相关)；
- 对于既可以使用外部接口，又可以使用回调去实现的功能，优先考虑使用外部接口：
  - 回调接口使用时，会陷入应用代码，应用代码往往处于开发阶段，存在缺陷等，如栈溢出问题(预测不到应用到底会如何去实现回调接口)，排查问题会比较扯皮；
  - 回调接口属于异步模式，没有同步代码那么容易理解，增加使用者的使用难度；
  - 在组件内部需要实时去读取应用数据时，根据数据状态处理内部逻辑时可以考虑；
  - 另一种是做一部操作时需要使用回调接口，如事件通知触发，结果不能立即返回的场景；
- 注释规范：
  - 使用[doxygen](https://www.doxygen.nl/manual/commands.html)注释规范；
  - 使用`doxygen`软件来生成开放接口说明文档；

----

#### 3.2.3 迭代与维护

组件偏向发布，存在独立的迭代与维护，在这个过程中需要严格注意：版本变化，兼容性。

- 版本：
  - 组件必须提供版本号，且符合[语义化版本2.0](https://semver.org/lang/zh-CN/)标准；
  - 每个版本的变更需要提供详细的说明；
  - 版本管理工具`svn,git`等需要充分利用，通常进行最小粒度的提交；
  - 稳定阶段性版本通常需要`tag`；
- 兼容性，组件兼容性绝大部分由接口兼容性引起(所以不要随意修改数据结构和接口)，在兼容性方面注意以下问题：
  - 不兼容版本的主版本号一定不同；
  - 接口兼容性：
    - 内部实现变更，但对使用者的功能无影响，此时开放接口不能做仍和修改；
    - 对使用者的功能无影响，但是组件协议变更。此时原有接口不能做任何修改，添加新接口以适用新的协议策略。新接口与原接口命名保持一致，添加能表明新特性的后缀，不建议使用v1,v2标识(除非就是协议的版本)，并在就接口的注释中添加不建议使用说明。如`c`标准库提供的安全性更高的字符串接口族；
    - 组件功能新增，原有功能无变更，此时开放接口不能做任何修改；
    - 接口需要废弃时，一般不会立即弃用，版本发布时对将要废弃的接口加以说明，表明什么原因、什么时候将不再支持，指导实际废弃时才删除掉，发布不兼容版本，主要是为了给使用者一个版本切换的缓冲时间；

----

#### 3.2.4 依赖库

组件开发时不可避免会用到一些依赖库，有来自公司内部，也有开源库。对于依赖库的使用注意以下几点：

- [从copyright到Copyleft，聊聊版权与开源协议](https://my.oschina.net/editorial-story/blog/4259721)；
- [开源许可证教程](http://www.runyifeng.com/blog/2017/10/open-source-license-tutorial.html)；
- 多个组件务必使用类似的构建方式，以便在使用时相对简单；
- 选择成熟、持续维护的依赖库；

----

#### 3.2.5 构建发布

组件的构建与发布需要考虑到的是简单易用：添加删除源码文件简单，指令选项简单，无需复杂配置。

当前组件建议采用`Makefile`的形式进行构建，关于组件构建时需要提供的基础指令有以下注意点：

- 提供单纯的组件编译指令(包含源码与文档)；
- 提供组件编译中间生成物清除指令；
- 提供组件成果物安装指令，并可以传入安装路径；
- 提供指定编译器选项，用于跨平台构建；

----

#### 3.2.6 文档

文档说明是软件的重要组成部分，经常存在以下问题：

- 重要的需求、设计文档、使用文档缺失；
- 文档过期，没有及时更新，与当前的代码版本不一致；

产生的结果是只有开发者自己才能清除组件实现，时间过长后开发者自己也会忘记，其他人熟悉的周期过长；使用者需要花费更多时间去了解该如何使用，并且增加问答时间。

组件开发一般要提供以下文档：

- 需求文档；
- 概要设计
- 详细设计；
- 单元测试报告；
- 组件使用文档；
- 组件`API`文档；
- 组件导航文档；
- 版本修订记录，可以合并到详细设计文档；

----

#### 3.2.7 测试

**组件没有测试则不能发布**，组件的可靠性相比一般的应用程序而言要求更高，想象一下标准函数存在缺陷时的影响范围、使用者的问题排查难度。

组件测试可以通过以下几种方式：

1. 单元测试：属于自动化测试的一类。对组件提供的接口进行覆盖性测试，接口输入后得到预期的输出结果(正常输入数据，异常输入数据，边界)，很大程度上能排查出组件内部的语法、逻辑缺陷，并对没有测试环境的组件提供模拟测试。每种语言都有相应的开源单元测试框架；
2. `demo`测试：包含自动测试和手动测试。数据的输出有效性无法由组件开放接口简单逻辑判断进行校验的一类。如：视频播放，图片显示，协议，网络等。这一类的一般都需要编写测试`demo`，靠人的观察和测试代码校验综合得出测试结果；
3. 统计类(算法)测试：如果性能指标，视频丢帧，目标识别等。一般会有特定的测试代码，对待测试项进行结果记录，结果统计；还有一些则只能使用认为判断，如：显示效果，识别正确性等；

不管哪种测试，只要是关于组件功能和使用，每一方面都需要测试到。

此处重点说明单元测试，想要编写设计良好的组件、提高自身技术能力，坚持做单元测试的几点好处：

- 减少测试成本，不需要实际测试环境；
- 良好的测试总会比认为测试更为可靠、高效；
- 版本迭代、重构的保障(重新运行一次单元测试即可)；
- 越差的组件越难做单元测试，侧面检测组件设计优良性；

**测试要求，为组件发布前的测试项**：

- 单元测试，组件接口的基本功能需要覆盖；
- 稳定性测试，7*24小时不间断测试，长时间运行不受影响；
- 压力测试，如某些操作、请求频繁发生时，组件仍然能够正常工作；
- 资源损耗测试，如内存、CPU、FLASH等；

以上测试结果都需要反应在文档内。

----

#### 3.2.8 组件设计原则

组件设计原则即软件设计原则[7大原则](https://www.cnblogs.com/cainiao-chuanqi/p/10959800.html)：

- **开放闭合原则**；
  - 涉及到兼容性，扩展性问题；
- 里氏替换原则；
- **依赖倒置原则**；
  - `c`当中常见的是组件需要使用应用程序接口的情况。通常做法是由组件开放头文件定义接口类型，应用注该接口给组件，那么组件内部和应用都依赖于该接口类型；
- **接口隔离原则**；
  - 不要包含不需要的东西；
- **迪米特法则**；
  - 能够给间接使用的不要直接使用，减少不必要的依赖、降低使用风险。如组件基于某个`sdk`开发，那么组件就不应该开放`sdk`提供的接口给应用，应当由组件进行代理，例如`sdk`的某个接口不兼容了，但是可能经过组件封装能屏蔽掉不兼容的问题，此时只需要应用更新库重新编译即可，不需要修改代码。把修改的返回限定在组件内部，而不是组件外部(100份应用需要修改100次，组件只需要一次)；
- 合成复用原则；

**没有遵循设计原则的意识之前不要想着使用什么设计模式，设计模式是在代码质量已经过关的前提下才使用的具体技巧(设计原则的具体方法论)，遵循这些基本设计原则同样能编写出优良的代码。**

----

## 4. 文档修订记录

|    DATE    |    ITEM    |   Breif    |   Author   | Version  |
|------------|------------|------------|------------|----------|
|2021-06-26  | NEW        | 文档新建    | wotsen(astralrovers@outlook.com) | v1.0.0 |

----
